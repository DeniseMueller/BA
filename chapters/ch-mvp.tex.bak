\setcounter{secnumdepth}{3}
\subsubsection{Model-View Presenter}
Das Architekturmuster \ac{MVP} basiert auf dem \ac{MVC} Muster. Die Komponente wurden anhand hohen Flexibilit\"at angepasst und die M\"angel des vorherigen Musters (\ac{MVC}) werden besser gehandhabt.  Das Hauptmerkmal des \ac{MVP} Musters ist der Presenter, der direkten Zugriff auf die View und das Model besitzt und deren Zusammenspiel regelt. Die View und das Model k\"onnen kleine Situationen selbst handhaben, was das ganze die Komplexit\"at des Presenters reduziert, da dieser nur noch f\"ur die komplexen Anforderungen verantwortlich ist. Somit ist das Architektumuster \ac{MVP} das flexibelste der MV* Familie, da es dem Entwickler viel Freiraum und Kontrolle gibt. Zum Beispiel kann die Datenbindung an dem Punkt an dem der Entwickler es w\"unscht genutzt werden.\cite{Syromiatnikov2014}.\par\smallskip 
Die Views sind wie auch beim \ac{MVC} Muster f\"ur die Anschauung der Daten zust\"andig und das Model f\"ur die Datenhaltung verantwortlich. Martin Fowler verglich 2006 das Architekturmuster \ac{MVC} mit \ac{MVP} so, dass der Controller in \ac{MVC} bei  \ac{MVP} ein Teil der View ist\cite{Bragge2013}. Die Reaktion auf die Aktivit\"aten des Users sind Presenter enthalten. Er kann entscheiden wie das Model manipuliert und ver\"andert werden kann, hei\ss{}t er \"ubernimmt bzw. integriert die Rolle des Application Model, das man von \ac{MVC} kennt. Zusammenfassend zu sagen ist, dass der Presenter die Business Logik zur Verf\"ugung stellt.
In der Regel verh\"alt sich die Kommunikation gleich wie beim \ac{MVC}. Durch Aktionen des Anwenders, wie eine Mausbewegung, werden \texttt{Interactor Events} ausgel\"ost. Diese Interaktionen werden vom Presenter interpretiert\cite{Potel1996}.




